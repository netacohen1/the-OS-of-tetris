#include "interrupts.h"
#include "util.h"

typedef struct {
    u16     isr_low;            // lower 16 bit of ISR's address
    u16     kernel_cs;          // gdt segment selector
    u8      reserved;           // set to zero
    u8      attribute;          // attribute flags
    u16     isr_high;           // higher 16 bit of ISR's address
    
} PACKED idt_entry_32;

// IDTR layout
typedef struct{
    u16         limit;
    uintptr_t   base;
} PACKED idtr_32;

__attribute__((aligned(0x10))) static idt_entry_32 idt[256];
idtr_32 idtr;

void exception_handler(){
    __asm__ volatile("cli; hlt");
}

/* // interrputs frame to pass to the ISRs */
/* typedef struct{ */
/*     u32     eip; */
/*     u32     cs; */
/*     u32     elfags; */
/*     u32     sp; */
/*     u32     ss; */
/* } PACKED int_frame; */
/*  */
/* // defualt exception handler function (no error code) */
/* __attribute__((interrupt)) void default_excp_handler(int_frame* frame){ */
/*     __asm__ volatile("cli; hlt"); */
/* } */
/*  */
/* // defualt exception handler function (with error code) */
/* __attribute__((interrupt)) void default_excp_handler_error_code(int_frame* frame, u32 error_code){ */
/*     __asm__ volatile("cli; hlt"); */
/* } */
/*  */
/* // defualt interrupt hanler */
/* __attribute__((interrupt)) void default_int_handler(int_frame* frame){ */
/*     __asm__ volatile ("cli; hlt"); */
/* } */

// add an ISR to the IDT
void idt_set_descriptor(u8 entry_number, void* isr, u8 flags){
    idt_entry_32 *descriptor = &idt[entry_number];

    descriptor->isr_low     = (u32)isr & 0xFFFF;    // lower 16 bits of isr address
    descriptor->kernel_cs   = 0x08;                 // kernel code segment containing this isr
    descriptor->reserved    = 0;                    // set to zero
    descriptor->attribute   = flags;                // type and attributes
    descriptor->isr_high    = ((u32)isr >> 16) & 0xFFFF;       // higher 16 bits of isr address
}

// setup the idt
extern void* isr_stub_table[];
void set_IDT(void){
    idtr.base = (uintptr_t)idt;
    idtr.limit  = (u16)sizeof(idt)-1;

    for (u8 vector=0; vector<32; vector++){
        idt_set_descriptor(vector, isr_stub_table[vector], INTERRUPT_GATE_FLAGS);
    }

    // load the idt and enable interrupts
    __asm__ volatile("lidt %0": : "m"(idtr));
    __asm__ volatile("sti");
}
